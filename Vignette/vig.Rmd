---
title: "Example of Using blb4lm"
date: "3/20/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description

The `blb4lm` package contains function: blb4lm(), coef.blb4lm(), sigma.blb4lm(), predict.blb4lm(). These functions can help users quickly apply bag of little bootstrap on linear regression to get the estimates of coefficients and their standard deviation whether using parallel processing or distributed computing. Also, users can predict new data and its confidence interval with the new model. The `plan()` in package `furrr` will be used for parallel processing. 

```{r, message=FALSE}
library(blb4lm)
library(furrr) 
```


## blb4lm() 

The input data should include variables used in the estimating formula. All the variables used in linear regression should be numerical variable without NA.

```{r, message=FALSE}
# Input training data
grad_2018 <- read.csv('./Data/GRAD_RATE_AND_OUTCOMES_2018.csv', header = TRUE)

# Replace unknown data as NA
grad_2018$GRAD_PCT[grad_2018$GRAD_PCT == '-'] <- NA
grad_2018$LOCAL_PCT[grad_2018$LOCAL_PCT == '-'] <- NA
grad_2018$DROPOUT_PCT[grad_2018$DROPOUT_PCT == '-'] <- NA

# no NA is accept x and y in blb4lm()
# remove NA in data frame
library(tidyverse)
training_data <- grad_2018 %>%
  filter(!is.na(LOCAL_PCT) | !is.na(GRAD_PCT) | !is.na(DROPOUT_PCT))

# transfer factor to numeric
training_data$GRAD_PCT <- as.numeric(training_data$GRAD_PCT)
training_data$LOCAL_PCT <- as.numeric(training_data$LOCAL_PCT)
training_data$DROPOUT_PCT <- as.numeric(training_data$DROPOUT_PCT)
```


In `plan()` workers is defined as the number of cores in parallel processing. `object` and `object2` are defined as results of `blb4lm()`through `paralle` and distributed computing. The time of using parallel processing is much faster than distributed conputing, when the number of subsample and resampl is large enough.

```{r}
# use plan() to define number of workers before using parallel
plan(multiprocess, workers = 4)

system.time({
  object = blb4lm(GRAD_PCT ~ LOCAL_PCT + DROPOUT_PCT, 100, 1000, training_data, parallel = TRUE)
})

system.time({
  object2 = blb4lm(GRAD_PCT ~ DROPOUT_PCT + LOCAL_PCT, 100, 1000, training_data, parallel = FALSE)
})
```


The result give a list including coefficients and sigma in 1000 (the number of resample) lists in 100 (the number of subsample) lists. `print()` will give a brif description of result `object`. 

```{r}
object[[1]][[1]][[1]]

print(object)
```


## Coefficients and Sigma

After object is formed from blb4lm(), coefficients and cofidence can be calculated by coef(). Sigma and its confidence interval can be calculated by sigma()

```{r}
coef(object, confidence = TRUE, level = 0.95)

sigma(object, confidence = TRUE, level = 0.95)
```


## Predict y

The `new_data` in `predict()` should only include the predictors (x) in `blb4lm()` with same number and same header. Here 'predict_data' is defined as data frame of predictors. All variables in `predict_data` should also in numerical and remove NA.

```{r}
# Input new dataset as new_data
grad_2019 <- read.csv('./Data/GRAD_RATE_AND_OUTCOMES_2019.csv', header = TRUE)

# Only Choose predictor (x) in predict_data as new_data in predict()
predict_data <- grad_2019[c(1:10),c(23,25)]

# transfer factor to numeric
predict_data$LOCAL_PCT <- as.numeric(predict_data$LOCAL_PCT)
predict_data$DROPOUT_PCT <- as.numeric(predict_data$DROPOUT_PCT)
```


'predicted_y` is predicted from given x with confidence intercal. Show predictor x (`DROPOUT_PCT`, `LOCAL_PCT`), `Predict_y`, confidence intercal in one table.

```{r}
(predicted_y <- predict(object, predict_data, confidence = TRUE, level = 0.95))

predict_data <- predict_data %>%
  mutate(predicted_y[[1]]) %>%
  mutate(predicted_y[[2]][c(1:10)]) %>%
  mutate(predicted_y[[2]][c(11:20)])

(predict_data %>%
  rename('Predict_y' = 'predicted_y[[1]]') %>%
  rename('2.5%' = 'predicted_y[[2]][c(1:10)]') %>%
  rename('97.5%' = 'predicted_y[[2]][c(11:20)]'))
```
